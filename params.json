{"tagline":"Go! Lisp in OCaml","body":"GoLio is a Lisp dialect implemented in OCaml. The syntax, semantics and library procedures are a subset of [R5RS](http://www.schemers.org/Documents/Standards/R5RS/), with one important addition: a [Go](http://golang.org/)-like concurrency model.\r\n\r\n## Yet another Lisp interpreter ...\r\n\r\n```scheme\r\n> (define (curry func arg1) (lambda (arg) (apply func arg1 (list arg))))\r\n> (map (curry + 2) '(1 2 3 4))\r\n(3 4 5 6) ;; just plain old s-expressions\r\n\r\n> (letrec ((even? (lambda (n) (if (= 0 n) #t (odd? (- n 1)))))\r\n           (odd?  (lambda (n) (if (= 0 n) #f (even? (- n 1))))))\r\n           (even? 9875321))\r\n#f ;; proper tail recursion is implemented\r\n\r\n> `(1 2 `(10 ,',(+ 2 3)))\r\n(1 2 `(10 ,'5)) ;; nested quasiquote is not very easy to implement right\r\n```\r\n\r\n## ... with Fibers and Channels\r\n\r\nUse the `go` macro to start new `fiber`s:\r\n\r\n```scheme\r\n> (go (begin (write 1) (write 2) (write 3))\r\n      (begin (write 'a) (write 'b) (write 'c)))\r\n1a2b3c > ;; this is one possible output\r\n```\r\n\r\nThe `fiber`s can communicate with each other using `chan`s:\r\n\r\n```scheme\r\n(define ping-chan (make-chan))\r\n(define pong-chan (make-chan))\r\n\r\n(define (ping)\r\n  (write (receive ping-chan)) ;; receive and write \"ping-\"\r\n  (send pong-chan 'pong-) ;; and pong back\r\n  (ping))\r\n\r\n(define (pong)\r\n  (send ping-chan 'ping-) ;; send a ping\r\n  (write (receive pong-chan)) ;; and write the received \"pong-\"\r\n  (pong))\r\n\r\n(go (ping)\r\n    (pong))\r\n\r\n;; the output will be ping-pong-ping-pong-ping-pong-...\r\n```\r\n\r\n## Deadlock detection\r\n\r\nIf the `pong` function is written like this:\r\n\r\n```scheme\r\n(define (pong)\r\n  (write (receive pong-chan)) ;; write the received \"pong-\"\r\n  (send ping-chan 'ping-) ;; and send a ping\r\n  (pong))\r\n```\r\n\r\nThe GoLio interpreter will detect the deadlock and raise exception:\r\n\r\n```\r\n$ ./golio deadlock-ping-pong.scm\r\nDead_lock\r\nFatal error: exception Type.Dead_lock\r\nRaised at file \"src/repl.ml\", line 51, characters 17-26\r\nCalled from file \"src/golio.ml\", line 30, characters 10-215\r\n```\r\n\r\n## Implemented in OCaml\r\n\r\nGoLio is mainly for me to learn the beautiful programming language OCaml while exploring lisp interpreter implementation and concurrent programming.\r\n\r\nThe `fiber`s are implemented using [OCaml threads](http://caml.inria.fr/pub/docs/manual-ocaml/libref/Thread.html), and `chan`s are implemented using [Event.channel](http://caml.inria.fr/pub/docs/manual-ocaml/libref/Event.html#TYPEchannel).\r\n\r\nDeadlock detection is implemented by keep a record on how many threads are currently waiting/blocked, and how many threads are active/working. If all of the threads are blocked waiting for sending to or receiving from some channel, then we have a deadlock. For a certain channel, it is necessary to keep a record on how many threads are currently waiting for sending to or receiving from it. In that way, when a new send or receive request is issued, whether the calling thread will be blocked by this request can be known and counted.\r\n\r\nBuffered channels like in those in [Go](http://golang.org) is once implemented but eventually abandoned in the 0.1 version, since my implementation using [Queue.t](http://caml.inria.fr/pub/docs/manual-ocaml/libref/Queue.html#TYPEt) does not play well with the deadlock detection. But this feature will surely appear in version 0.2.\r\n\r\n## A Fully Working Example\r\n\r\nHere is a [prime sieve](https://github.com/tianyicui/golio/blob/master/tests/sieve.scm) implemented in GoLio:\r\n\r\n```scheme\r\n;; send 2..n to chan `ch`\r\n(define (gen ch n)\r\n  (let loop ((i 2))\r\n    (if (<= i n)\r\n      (begin\r\n        (send ch i)\r\n        (loop (+ i 1)))))\r\n  (close-chan ch))\r\n\r\n;; receive from chan `in` and filter out all multipliers of `m`, send the rest\r\n;; to chan `out`.\r\n(define (filter in out m)\r\n  (let ((x (receive in)))\r\n    (if (eof-object? x)\r\n      (close-chan out)\r\n      (begin\r\n        (if (/= 0 (% x m))\r\n          (send out x))\r\n        (filter in out m)))))\r\n\r\n;; filter out all the non-primes from chan `in` and send the primes to chan `out`\r\n(define (sieve in out)\r\n  (let ((x (receive in)))\r\n    (if (eof-object? x)\r\n      (close-chan out)\r\n      (let ((ch (make-chan)))\r\n        (send out x)\r\n        (go (filter in ch x))\r\n        (sieve ch out)))))\r\n\r\n;; get the threads going\r\n(define in (make-chan))\r\n(define out (make-chan))\r\n(go (gen in 1000)\r\n    (sieve in out))\r\n\r\n;; receive all the primes and print them\r\n(let loop ()\r\n  (let ((x (receive out)))\r\n    (if (not (eof-object? x))\r\n      (begin\r\n        (write x)\r\n        (newline)\r\n        (loop)))))\r\n```\r\n\r\n## Thanks\r\n\r\nGoLio is my first OCaml project ever. It is currently in a very alpha state and under heavy development. I learned so much from writing and polishing it and had so much fun. If you have any comments, suggestion or questions, please feel free to [get in touch](tianyicui@gmail.com). Thanks for viewing!","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"GoLio","google":"UA-8949203-5"}